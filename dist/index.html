<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Google API Fields Builder</title>

    <!-- Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />

    <!-- CSS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default/style.min.css"
    />
    <style>
      :root {
        --bg-color: #1e1e1e;
        --card-bg: #252526;
        --text-color: #d4d4d4;
        --accent-color: #007acc;
        --accent-hover: #0098ff;
        --border-color: #3e3e42;
        --input-bg: #3c3c3c;
        --success-color: #4ec9b0;
        --error-color: #f48771;
      }

      body {
        font-family: "Roboto", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        padding: 20px;
        line-height: 1.6;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        background-color: var(--card-bg);
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }

      header {
        margin-bottom: 30px;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
      }

      h1 {
        margin: 0;
        font-size: 24px;
        color: var(--text-color);
      }

      .meta {
        font-size: 14px;
        color: #888;
        margin-top: 5px;
      }

      a {
        color: var(--accent-color);
        text-decoration: none;
      }

      a:hover {
        text-decoration: underline;
      }

      .controls-section {
        display: grid;
        gap: 15px;
        margin-bottom: 20px;
      }

      .control-group {
        display: flex;
        flex-direction: column;
      }

      label {
        font-size: 14px;
        margin-bottom: 5px;
        font-weight: 500;
      }

      input[type="text"],
      select {
        background-color: var(--input-bg);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        padding: 10px;
        border-radius: 4px;
        font-size: 14px;
        outline: none;
        width: 100%; /* Ensure full width */
        box-sizing: border-box; /* Include padding in width */
      }

      input[type="text"]:focus,
      select:focus {
        border-color: var(--accent-color);
      }

      .doc-link {
        font-size: 16px;
        margin-left: 5px;
        cursor: pointer;
      }

      .status-message {
        margin: 10px 0;
        min-height: 20px;
        font-size: 14px;
      }

      .status-message.error {
        color: var(--error-color);
      }
      .status-message.success {
        color: var(--success-color);
      }
      .status-message.info {
        color: var(--accent-color);
      }

      .fields-section {
        margin-top: 20px;
        background-color: #2d2d30;
        padding: 15px;
        border-radius: 4px;
        border: 1px solid var(--border-color);
      }

      .fields-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
      }

      #fieldvalue {
        width: 100%;
        box-sizing: border-box;
        font-family: "Consolas", "Monaco", monospace;
        background-color: #1e1e1e;
      }

      .hint {
        font-size: 12px;
        color: #888;
        margin: 5px 0 0 0;
      }

      .tree-controls {
        margin: 20px 0 10px 0;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .btn {
        background-color: var(--input-bg);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
        flex: 1 0 auto; /* Allow buttons to grow and shrink */
        text-align: center;
      }

      .btn:hover {
        background-color: #4e4e50;
      }

      .btn-small {
        background-color: var(--accent-color);
        color: white;
        border: none;
        padding: 4px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .btn-small:hover {
        background-color: var(--accent-hover);
      }

      .tree-container {
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 10px;
        background-color: var(--input-bg);
        max-height: 500px;
        overflow-y: auto;
      }

      /* jstree dark theme overrides */
      .jstree-default .jstree-anchor {
        color: var(--text-color) !important;
        word-break: break-all; /* Prevent long field names from overflowing */
      }
      .jstree-default .jstree-hovered {
        background: #4e4e50 !important;
        box-shadow: none !important;
      }
      .jstree-default .jstree-clicked {
        background: var(--accent-color) !important;
        color: white !important;
        box-shadow: none !important;
      }
      .jstree-default .jstree-wholerow-hovered {
        background: #4e4e50 !important;
      }
      .jstree-default .jstree-wholerow-clicked {
        background: var(--accent-color) !important;
        background: linear-gradient(
          to bottom,
          var(--accent-color) 0%,
          var(--accent-color) 100%
        ) !important;
      }
      /* Fix checkbox visibility in dark mode if they are images */
      .jstree-default .jstree-checkbox {
        filter: invert(1) hue-rotate(180deg);
      }

      /* Mobile Responsiveness */
      @media (max-width: 600px) {
        body {
          padding: 10px;
        }

        .container {
          padding: 15px;
        }

        h1 {
          font-size: 20px;
        }

        .meta {
          font-size: 12px;
        }

        .btn {
          padding: 10px; /* Larger touch target */
          font-size: 14px;
          width: 100%; /* Full width buttons on mobile */
          margin-bottom: 5px;
        }

        .tree-controls {
          flex-direction: column;
          gap: 5px;
        }

        .fields-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }

        .fields-header button {
          width: 100%;
          padding: 8px;
        }
      }
    </style>

    <!-- Scripts -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/jstree.min.js"></script>
  </head>

  <body>
    <div class="container">
      <header>
        <h1>Google API Fields Builder</h1>
        <div class="meta">
          <span
            >Author:
            <a href="https://tanaikech.github.io/" target="_blank"
              >Tanaike</a
            ></span
          >
          <span
            >GitHub:
            <a
              href="https://github.com/tanaikech/FieldsBuilderForGoogleAPIs"
              target="_blank"
              >Repo</a
            ></span
          >
        </div>
      </header>

      <div class="controls-section">
        <div class="control-group">
          <label for="searchapi">Search API</label>
          <input
            type="text"
            id="searchapi"
            placeholder="e.g., Drive, Sheets..."
          />
        </div>

        <div class="control-group">
          <label for="selectapi"
            >Select API
            <a
              id="documenturl"
              target="_blank"
              class="doc-link"
              title="Open Official Documentation"
              >ðŸ“š</a
            ></label
          >
          <select id="selectapi">
            <option value="">Loading APIs...</option>
          </select>
        </div>

        <div class="control-group" id="selectresourcediv" style="display: none">
          <label for="selectresource">Resource</label>
          <select id="selectresource"></select>
        </div>

        <div class="control-group" id="selectmethoddiv" style="display: none">
          <label for="selectmethod">Method</label>
          <select id="selectmethod"></select>
        </div>
      </div>

      <div id="status" class="status-message"></div>

      <div id="fields" class="fields-section" style="display: none">
        <div class="fields-header">
          <label for="fieldvalue">Generated Fields Parameter</label>
          <button id="copyfields" class="btn-small">Copy</button>
        </div>
        <input
          type="text"
          id="fieldvalue"
          readonly
          placeholder="Select fields from the tree below..."
        />
        <p class="hint">
          Copy this string to the <code>fields</code> property in your API
          request.
        </p>
      </div>

      <div id="checkcontrol" class="tree-controls" style="display: none">
        <button type="button" id="openall" class="btn">Expand All</button>
        <button type="button" id="closeall" class="btn">Collapse All</button>
        <button type="button" id="checkall" class="btn">Select All</button>
        <button type="button" id="uncheckall" class="btn">Deselect All</button>
      </div>

      <div id="tree" class="tree-container" style="display: none"></div>
    </div>

    <script type="text/javascript">
      const apiObj = {};
      let methodObj = {};

      // Initialize application
      $(document).ready(() => {
        loadAPIList();
        initJsTree();
        setupEventHandlers();
      });

      function setupEventHandlers() {
        $("#searchapi").on("input", handleSearch);
        $("#selectapi").on("change", handleApiChange);
        $("#selectresource").on("change", handleResourceChange);
        $("#selectmethod").on("change", handleMethodChange);

        $("#checkall").on("click", () => {
          $("#tree").jstree().check_all();
          createFields();
        });

        $("#uncheckall").on("click", () => {
          $("#tree").jstree().uncheck_all();
          $("#fieldvalue").val("");
        });

        $("#openall").on("click", () => $("#tree").jstree().open_all());
        $("#closeall").on("click", () => $("#tree").jstree().close_all());

        // Copy to clipboard
        $("#copyfields").on("click", () => {
          const copyText = document.getElementById("fieldvalue");
          copyText.select();
          copyText.setSelectionRange(0, 99999);
          document.execCommand("copy");
          showStatus("Copied to clipboard!", "success");
        });
      }

      function showStatus(message, type = "info") {
        const status = $("#status");
        status.text(message);
        status.removeClass("error success info").addClass(type);
        if (type === "success") {
          setTimeout(() => status.text(""), 3000);
        }
      }

      function initJsTree() {
        // If jstree is already initialized, destroy it first
        if ($.jstree.reference("#tree")) {
          $("#tree").jstree("destroy");
        }

        $("#tree").jstree({
          plugins: ["wholerow", "checkbox"],
          core: {
            check_callback: true,
            themes: {
              name: "default",
              dots: true,
              icons: false,
            },
            data: [],
          },
          checkbox: {
            whole_node: true,
            tie_selection: false,
          },
        });

        $("#tree").on("check_node.jstree uncheck_node.jstree", () =>
          createFields()
        );
      }

      async function loadAPIList() {
        try {
          const res = await fetch(
            "https://www.googleapis.com/discovery/v1/apis"
          );
          const obj = await res.json();

          // Store globally
          Object.assign(apiObj, obj);

          const select = $("#selectapi");
          select.empty();
          select.append($("<option>").val("").text("Select an API..."));

          obj.items
            .sort((a, b) => a.title.localeCompare(b.title))
            .forEach((e) => {
              select.append(
                $("<option>").val(e.id).text(`${e.title} (${e.version})`)
              );
            });
        } catch (err) {
          console.error(err);
          showStatus("Failed to load API list.", "error");
        }
      }

      function handleSearch() {
        clearResourceList();
        const val = $(this).val().toLowerCase();
        const select = $("#selectapi");
        select.empty();

        const values = apiObj.items
          .filter(
            (e) =>
              e.title.toLowerCase().includes(val) ||
              e.name.toLowerCase().includes(val)
          )
          .sort((a, b) => a.title.localeCompare(b.title));

        if (values.length === 0) {
          select.append($("<option>").val("").text("No APIs found"));
          return;
        }

        values.forEach((e) => {
          select.append(
            $("<option>").val(e.id).text(`${e.title} (${e.version})`)
          );
        });

        if (values.length === 1) {
          select.prop("selectedIndex", 0);
          handleApiChange();
        }
      }

      async function handleApiChange() {
        const val = $("#selectapi").val();
        if (!val) return;

        const [api, version] = val.split(":"); // This might fail if id doesn't have colon, but standard discovery IDs do.
        // Fallback if split doesn't work as expected (some IDs might be different)
        const selectedApiItem = apiObj.items.find((i) => i.id === val);
        if (!selectedApiItem) return;

        await loadDiscoveryDocument(selectedApiItem.discoveryRestUrl);
      }

      async function loadDiscoveryDocument(url) {
        try {
          showStatus("Loading discovery document...", "info");
          const res = await fetch(url);
          methodObj = await res.json();

          $("#selectresourcediv").show();
          const select = $("#selectresource");
          select.empty();
          select.append($("<option>").val("").text("Select a Resource..."));

          clearMethodList();

          // Flatten resources to handle nesting
          const resources = getAllResources(methodObj);
          resources.sort().forEach((r) => {
            select.append($("<option>").val(r).text(r));
          });

          showStatus("API loaded. Select a resource.", "info");
        } catch (err) {
          console.error(err);
          showStatus("Failed to load discovery document.", "error");
        }
      }

      // Recursive function to get all resource paths
      function getAllResources(root, parentPath = "") {
        let paths = [];
        if (root.resources) {
          for (const [key, value] of Object.entries(root.resources)) {
            const currentPath = parentPath ? `${parentPath}.${key}` : key;
            paths.push(currentPath);
            paths = paths.concat(getAllResources(value, currentPath));
          }
        }
        return paths;
      }

      function handleResourceChange() {
        clearMethodList();
        const resourcePath = $("#selectresource").val();
        if (!resourcePath) return;

        loadMethodList(resourcePath);
      }

      function loadMethodList(resourcePath) {
        const select = $("#selectmethod");
        select.empty();
        select.append($("<option>").val("").text("Select a Method..."));

        // Navigate to the resource object
        const parts = resourcePath.split(".");
        let current = methodObj;
        for (const part of parts) {
          if (current.resources && current.resources[part]) {
            current = current.resources[part];
          } else {
            console.error("Resource path not found:", resourcePath);
            return;
          }
        }

        if (current.methods) {
          const methods = Object.keys(current.methods).sort();
          methods.forEach((m) => {
            select.append($("<option>").val(m).text(m));
          });
          $("#selectmethoddiv").show();
        } else {
          showStatus("No methods found for this resource.", "info");
        }
      }

      function handleMethodChange() {
        const method = $("#selectmethod").val();
        const resourcePath = $("#selectresource").val();
        if (!method || !resourcePath) return;

        // Navigate to the method object
        const parts = resourcePath.split(".");
        let current = methodObj;
        for (const part of parts) {
          current = current.resources[part];
        }
        const methodData = current.methods[method];

        // Update documentation link
        if (methodObj.documentationLink) {
          $("#documenturl").attr("href", methodObj.documentationLink);
        }

        $("#fields").show();
        $("#fieldsexp").show();
        $("#checkcontrol").show();
        $("#tree").show();
        $("#fieldvalue").val("");

        loadTree(methodData);
      }

      function loadTree(methodData) {
        if (!methodData.response || !methodData.response.$ref) {
          $("#tree").hide();
          showStatus(
            "This method does not return a response body with fields to select.",
            "info"
          );
          return;
        }

        const schemaName = methodData.response.$ref;
        const schemas = methodObj.schemas;

        if (!schemas || !schemas[schemaName]) {
          $("#tree").hide();
          showStatus("Schema definition not found.", "error");
          return;
        }

        showStatus("Building tree...", "info");

        // Build tree data handling circular references
        const treeData = buildTreeData(
          schemas[schemaName],
          schemas,
          "#",
          [],
          schemaName
        );

        $("#tree").jstree(true).settings.core.data = treeData;
        $("#tree").jstree(true).refresh();

        showStatus("");
      }

      function buildTreeData(
        schema,
        allSchemas,
        parentId,
        visitedRefs,
        currentRefName
      ) {
        const data = [];

        // Helper to process properties
        const processProperties = (props, pId) => {
          for (const [key, prop] of Object.entries(props)) {
            const nodeId = pId === "#" ? key : `${pId}/${key}`;

            // Skip simple types if they are not containers, but we want to show all selectable fields
            // Actually, we want to show everything that can be a field.

            const node = {
              id: nodeId,
              text: key,
              parent: pId,
              icon: false,
            };

            data.push(node);

            // Check for recursion/nested objects
            let nextSchema = prop;
            let refName = null;

            if (prop.$ref) {
              refName = prop.$ref;
              nextSchema = allSchemas[refName];
            } else if (prop.type === "array" && prop.items) {
              if (prop.items.$ref) {
                refName = prop.items.$ref;
                nextSchema = allSchemas[refName];
              } else if (
                prop.items.type === "object" ||
                prop.items.properties
              ) {
                nextSchema = prop.items;
              }
            }

            if (
              nextSchema &&
              (nextSchema.properties || nextSchema.additionalProperties)
            ) {
              // Cycle detection
              if (refName && visitedRefs.includes(refName)) {
                // Cycle detected, stop recursion for this branch
                // Optionally add a visual indicator or just leaf node
                // For fields selection, we usually don't need infinite depth.
                // Google APIs usually support wildcards or specific depth, but here we just stop.
                continue;
              }

              const newVisited = refName
                ? [...visitedRefs, refName]
                : [...visitedRefs];

              // If it has properties, recurse
              if (nextSchema.properties) {
                const childData = buildTreeData(
                  nextSchema,
                  allSchemas,
                  nodeId,
                  newVisited,
                  refName
                );
                data.push(...childData);
              }
            }
          }
        };

        if (schema.properties) {
          processProperties(schema.properties, parentId);
        }

        return data;
      }

      function createFields() {
        const checkedNodes = $("#tree").jstree("get_checked", true);

        if (checkedNodes.length === 0) {
          $("#fieldvalue").val("");
          return;
        }

        // Create a Set of checked IDs for fast lookup
        const checkedIds = new Set(checkedNodes.map((n) => n.id));

        // Filter out nodes whose parent is also checked
        // This ensures that if a parent is selected (implying all children), we only include the parent
        const topLevelChecked = checkedNodes.filter(
          (n) => !checkedIds.has(n.parent)
        );

        const root = {};

        topLevelChecked.forEach((node) => {
          // The ID is constructed as "path/to/node" (or just "node" for top level)
          // However, we should be careful if IDs contain other characters.
          // In buildTreeData we used: const nodeId = pId === "#" ? key : `${pId}/${key}`;
          // So splitting by '/' is correct assuming keys don't contain '/'.
          // Google API field names don't contain '/'.

          const path = node.id;
          const parts = path.split("/");
          let current = root;

          parts.forEach((part, index) => {
            if (!current[part]) {
              // If it's the last part, mark as true (leaf of selection)
              // Otherwise create object for nesting
              current[part] = index === parts.length - 1 ? true : {};
            } else if (current[part] === true) {
              // If we encounter a node that is already marked as true, it means a parent was selected.
              // But our filtering logic should prevent this case (we only process top-level checked).
              // So this branch might not be reached, but good to keep existing value.
            }

            // Navigate deeper if it's an object
            if (current[part] !== true) {
              current = current[part];
            }
          });
        });

        // Now convert root object to fields string
        const fieldsString = stringifyFields(root);
        $("#fieldvalue").val(fieldsString);
      }

      function stringifyFields(obj) {
        if (obj === true) return "";

        const parts = [];
        for (const [key, value] of Object.entries(obj)) {
          if (value === true) {
            parts.push(key);
          } else {
            const sub = stringifyFields(value);
            if (sub) {
              parts.push(`${key}(${sub})`);
            } else {
              parts.push(key);
            }
          }
        }
        return parts.join(",");
      }

      function clearResourceList() {
        $("#selectresourcediv").hide();
        $("#selectresource").empty();
        clearMethodList();
      }

      function clearMethodList() {
        $("#selectmethoddiv").hide();
        $("#selectmethod").empty();
        $("#fields").hide();
        $("#fieldsexp").hide();
        $("#checkcontrol").hide();
        $("#tree").hide();
        $("#fieldvalue").val("");
        $("#status").text("");
        $("#documenturl").removeAttr("href");
      }
    </script>
  </body>
</html>
